import numpy as np
import pychrono as chrono

class FlightParams:
  def __init__(self):
    self.G_acc = 9.80665 # Gravitational acceleration

    # Rotation Matrix that represents a fixed rotation of PI/2 rad around the X-Axis
    RotMat_X_PI_2_list = [[1,  0,  0],
                          [0,  0,  1],
                          [0, -1,  0]]
    RotMat_X_PI_2_array = np.array(RotMat_X_PI_2_list)
    # Rotation Matrix that represents a fixed rotation of -PI/2 rad around the X-Axis
    RotMat_X_PI_2_tran_array = np.transpose(RotMat_X_PI_2_array)
    # Inertia matrix of the system: (drone frame + box + propellers) espressed in Solidworks coordinate sys (x-front, y-up, z-right), computed at the center of mass
    Inertia_mat_sw = np.array([[ 0.0227199027,  0.0010034978, -0.0000065570],
                               [ 0.0010034978,  0.0161469360, -0.0000056584],
                               [-0.0000065570, -0.0000056584,  0.0220204718]])
    # Inertia matrix of the system: (drone frame + box + propellers) espressed in Pixhawk coordinate sys (x-front, y-right, z-down), computed at the center of mass
    self.Inertia_mat_pixhawk = np.matmul(RotMat_X_PI_2_array, np.matmul(Inertia_mat_sw, RotMat_X_PI_2_tran_array))
    
    self.air_density = 1.225 # Air density [kg/m^3]
    self.surface_area = 0.07 # Surface area of the drone to account for drag [m^2]
    self.drag_coefficient = 1.28 # Drag coefficient (equal to that of a plate) [-]

    self.mass_total_estimated = 2.025 # [kg] 2.025 -- 3.1
    self.I_matrix_estimated = np.matrix(self.Inertia_mat_pixhawk)
    self.air_density_estimated = self.air_density
    self.surface_area_estimated = self.surface_area
    self.drag_coefficient_estimated = self.drag_coefficient
    self.drag_coefficient_matrix_estimated = np.matrix(np.diag([self.drag_coefficient_estimated,self.drag_coefficient_estimated,0]))

    # Roll filters gains (from matlab)
    self.A_phi_ref = np.matrix([[-15, -225],[1, 0]])
    self.B_phi_ref = np.array([[1],[0]])
    self.C_phi_ref = np.matrix([225, 0])
    self.D_phi_ref = 0
    # Pitch filters gains (from matlab)
    self.A_theta_ref = np.matrix([[-15, -225],[1, 0]])
    self.B_theta_ref = np.array([[1],[0]])
    self.C_theta_ref = np.matrix([225, 0])
    self.D_theta_ref = 0

    # Mixer Matrix for the realization of the thrust generated by each motor (T1, T2, T3, T4) given the control inputs (u1, u2, u3, u4)
    l_x = 0.0881269 # distance between centerline of the drone and the motors along x direction in Local NED convention
    l_y = 0.1083450 # distance between centerline of the drone and the motors along y direction in Local NED convention
    c_t = 0.01 # drag coefficient of propellers

    # Mixer matrix for QUADcopter 
    # U_mat = np.array([[ 1,    1,    1,    1  ], 
    #                   [ l_y,  l_y, -l_y, -l_y],
    #                   [-l_x,  l_x,  l_x, -l_x],
    #                   [-c_t,  c_t, -c_t,  c_t]])
    
    # Mixer matrix for X8copter configuration
    # [   1,   1,    1,    1,    1,    1,    1,    1]
    # [ l_y, l_y, -l_y, -l_y,  l_y,  l_y, -l_y, -l_y]
    # [-l_x, l_x,  l_x, -l_x, -l_x,  l_x,  l_x, -l_x]
    # [-c_t, c_t, -c_t,  c_t,  c_t, -c_t,  c_t, -c_t]

    # Moore-Penrose pseudo-inverse of X8copter mixer matrix
    self.U_mat_inv = np.array([
      [1/8,  1/(8*l_y), -1/(8*l_x), -1/(8*c_t)],
      [1/8,  1/(8*l_y),  1/(8*l_x),  1/(8*c_t)],
      [1/8, -1/(8*l_y),  1/(8*l_x), -1/(8*c_t)],
      [1/8, -1/(8*l_y), -1/(8*l_x),  1/(8*c_t)],
      [1/8,  1/(8*l_y), -1/(8*l_x),  1/(8*c_t)],
      [1/8,  1/(8*l_y),  1/(8*l_x), -1/(8*c_t)],
      [1/8, -1/(8*l_y),  1/(8*l_x),  1/(8*c_t)],
      [1/8, -1/(8*l_y), -1/(8*l_x), -1/(8*c_t)]
    ])

    # Maximum thrust produced by a single motor = 1355 grams = 1.355 kg = 1.355 kg * 9.81 m/s^2 = 13.28 N
    # Maximum thrust produced by a motors'couple without loss of efficiency due to propeller interaction = 13.28 * 2 = 26.56 N
    # Maximum thrust produced by a motors'couple considering loss of efficiency due to propeller interaction = 26.56 N * 0.8 = 21.25 N
    # For reference see: https://www.getfpv.com/t-motor-pacer-v3-p2306-powerful-freestyle-motor-1750kv-1950kv-2550kv.html
    # self.maximum_motor_thrust = 21.25 # [N] Maximum thrust that can be produced by a motors'couple
    self.maximum_motor_thrust = 21.25/2 # [N] Maximum thrust that can be produced by a SINGLE motor = 10.625 N
    
    # Minimum thrust produced by a single motor = 80 grams = 0.08 kg = 0.08 kg * 9.81 m/s^2 = 0.7848 N
    # Minimum thrust produced by a motors'couple without loss of efficiency due to propeller interaction = 0.7848 * 2 = 1.5696 N
    # Minimum thrust produced by a motors'couple considering loss of efficiency due to propeller interaction = 1.5696 N * 0.8 = 1.255 N
    # self.minimum_motor_thrust = 1.255 # [N] Minimum thrust that can be produced by a motors'couple
    self.minimum_motor_thrust = 1.255/2 # [N] Minimum thrust that can be produced by a SINGLE motor = 0.6275 N
    
    # Motor efficiency coefficients for simulating motor failure
    self.motor_efficiency_matrix = np.matrix(np.diag([1, 1, 1, 1, 1, 1, 1, 1]))
        
    self.K_omega = 0.0000014166615 # Coefficent relating the propellers'thrust to the square of the angular velocity. controller.motor_thrusts = K * omega^2
    self.K_torque = 5e-08 # [5e-08 - 5e-10] TO BE ESTIMATED!!! Coefficent relating the propellers'torque to the square of the angular velocity. Torque = K_torque * omega^2
 
    self.controller_start_time = 0.1 # Time after the start of simulation at which the controller is switched ON

    # position wrt local frame of where to apply the thrust force generated by motors 1 & 5
    self.force_1_5_pos = chrono.ChVectorD(-0.08760601358, -0.0085, -0.10859150436)
    # position wrt local frame of where to apply the thrust force generated by motors 2 & 6 
    self.force_2_6_pos = chrono.ChVectorD(0.08812691616, -0.0085, -0.10834502049) 
    # position wrt local frame of where to apply the thrust force generated by motors 3 & 7
    self.force_3_7_pos = chrono.ChVectorD(0.08760601358, -0.0085, 0.10859150436) 
    # position wrt local frame of where to apply the thrust force generated by motors 4 & 8
    self.force_4_8_pos = chrono.ChVectorD(-0.08812691616, -0.0085, 0.10834502049) 

    # Motors' rotation direction
    # Motor 1: CCW
    # Motor 2: CW
    # Motor 3: CCW
    # Motor 4: CW
    # Motor 5: CW
    # Motor 6: CCW       
    # Motor 7: CW
    # Motor 8: CCW
    # Define spin direction of each motor: +1 for CCW, -1 for CW
    self.propellers_spin_directions = [1, -1, 1, -1, -1, 1, -1, 1]