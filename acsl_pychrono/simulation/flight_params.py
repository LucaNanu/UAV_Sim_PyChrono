import numpy as np
import pychrono as chrono
import acsl_pychrono.config.config as Cfg

class FlightParams:
    def __init__(self, sim_cfg: Cfg.SimulationConfig = Cfg.SimulationConfig()):
        self.G_acc = 9.80665 # Gravitational acceleration
        
        self.air_density = 1.225 # Air density [kg/m^3]
        self.surface_area = 0.07 # Surface area of the drone to account for drag [m^2]
        self.drag_coefficient = 1.28 # Drag coefficient (equal to that of a plate) [-]
        self.controller_start_time = 0 # Time after the start of simulation at which the controller is switched ON
    
        # Roll filters gains (from matlab)
        self.A_phi_ref = np.matrix([[-15, -225],[1, 0]])
        self.B_phi_ref = np.array([[1],[0]])
        self.C_phi_ref = np.matrix([225, 0])
        self.D_phi_ref = 0
        # Pitch filters gains (from matlab)
        self.A_theta_ref = np.matrix([[-15, -225],[1, 0]])
        self.B_theta_ref = np.array([[1],[0]])
        self.C_theta_ref = np.matrix([225, 0])
        self.D_theta_ref = 0
        
        self.vehicle_config: Cfg.VehicleConfig = sim_cfg.vehicle_config
        if self.vehicle_config.vehicle_type == "thruststand_uav":
            self._init_ts_uav()
        elif self.vehicle_config.vehicle_type == "x8copter":
            self._init_x8copter()
        else:
            raise ValueError(f"Unknown vehicle_type: {self.vehicle_config.vehicle_type}")
        
    def _init_ts_uav(self):
        # Rotation Matrix that represents a fixed rotation of PI/2 rad around the X-Axis
        RotMat_X_PI_2_list = [[1,  0,  0],
                              [0,  0,  1],
                              [0, -1,  0]]
        RotMat_X_PI_2_array = np.array(RotMat_X_PI_2_list)
        # Rotation Matrix that represents a fixed rotation of -PI/2 rad around the X-Axis
        RotMat_X_PI_2_tran_array = np.transpose(RotMat_X_PI_2_array)
        # Inertia matrix of the system: (drone frame + box + propellers) espressed in Solidworks coordinate sys (x-front, y-up, z-right), computed at the center of mass
        Inertia_mat_sw = np.array([[0.01067891,  0.00007229, -0.00000114],
                                   [0.00007229,  0.02660994, -0.00000666],
                                   [-0.00000114, -0.00000666,  0.01731767]])
        # Inertia matrix of the system: (drone frame + box + propellers) espressed in Pixhawk coordinate sys (x-front, y-right, z-down), computed at the center of mass
        self.Inertia_mat_pixhawk = np.matmul(RotMat_X_PI_2_array, np.matmul(Inertia_mat_sw, RotMat_X_PI_2_tran_array))
    
        self.mass_total_estimated = 1.152 # [kg]
        self.I_matrix_estimated = np.matrix(self.Inertia_mat_pixhawk)
        self.air_density_estimated = self.air_density
        self.surface_area_estimated = self.surface_area
        self.drag_coefficient_estimated = self.drag_coefficient
        self.drag_coefficient_matrix_estimated = np.matrix(np.diag([self.drag_coefficient_estimated,self.drag_coefficient_estimated,0]))
    
        # Mixer Matrix for the realization of the thrust generated by each motor (T1, T2, T3, T4) given the control inputs (u1, u2, u3, u4)
        l_x = 0.15 # distance between centerline of the drone and the motors along x direction in Local NED convention
        l_y = 0.17 # distance between centerline of the drone and the motors along y direction in Local NED convention
        self.c_t = 0.0275 # drag coefficient of propellers. Torque to Thrust coefficient [Nm/N]. Recovered from 8x4.5MR propeller dynamical analysis
    
        # Mixer matrix for QUADcopter 
        # U_mat = np.array([[ 1,    1,    1,    1  ], 
        #                   [ l_y,  -l_y, -l_y, l_y],
        #                   [l_x,  l_x,  -l_x, -l_x],
        #                   [c_t,  -c_t, c_t,  -c_t]])
    
        # Moore-Penrose pseudo-inverse of ThrustStand UAV mixer matrix
        self.U_mat_inv = np.array([
          [1/4,  1/(4*l_y),  1/(4*l_x),  1/(4*self.c_t)],
          [1/4, -1/(4*l_y),  1/(4*l_x), -1/(4*self.c_t)],
          [1/4, -1/(4*l_y), -1/(4*l_x),  1/(4*self.c_t)],
          [1/4,  1/(4*l_y), -1/(4*l_x), -1/(4*self.c_t)]
        ])
        
        # Maximum thrust produced by a single motor = 1355 grams = 1.355 kg = 1.355 kg * 9.81 m/s^2 = 13.28 N
        # Maximum thrust produced by a motors'couple without loss of efficiency due to propeller interaction = 13.28 * 2 = 26.56 N
        # Maximum thrust produced by a motors'couple considering loss of efficiency due to propeller interaction = 26.56 N * 0.8 = 21.25 N
        # For reference see: https://www.getfpv.com/t-motor-pacer-v3-p2306-powerful-freestyle-motor-1750kv-1950kv-2550kv.html
        # self.maximum_motor_thrust = 21.25 # [N] Maximum thrust that can be produced by a motors'couple
        self.maximum_motor_thrust = 8.4188439 # [N] Maximum thrust that can be produced by a SINGLE motor = 10.625 N
        
        # Minimum thrust produced by a single motor = 80 grams = 0.08 kg = 0.08 kg * 9.81 m/s^2 = 0.7848 N
        # Minimum thrust produced by a motors'couple without loss of efficiency due to propeller interaction = 0.7848 * 2 = 1.5696 N
        # Minimum thrust produced by a motors'couple considering loss of efficiency due to propeller interaction = 1.5696 N * 0.8 = 1.255 N
        # self.minimum_motor_thrust = 1.255 # [N] Minimum thrust that can be produced by a motors'couple
        self.minimum_motor_thrust = 0.1434222 # [N] Minimum thrust that can be produced by a SINGLE motor = 0.6275 N
        
        # Motor efficiency coefficients for simulating motor failure
        self.motor_efficiency_matrix = np.matrix(np.diag([1, 1, 1, 1]))
            
        self.K_omega = 0.0000014166615 # Coefficent relating the propellers'thrust to the square of the angular velocity. controller.motor_thrusts = K * omega^2
        self.K_torque = 5e-08 # [5e-08 - 5e-10] TO BE ESTIMATED!!! Coefficent relating the propellers'torque to the square of the angular velocity. Torque = K_torque * omega^2
     
        # ThrustStand UAV Motors enumeration and Global reference frame (Reference frame acquired by SolidWorks)
        #
        #               
        #  1 - CW           2 - CCW
        #   \    forward   /
        #    \      ^ X   /
        #     \     |    /
        #      \____|___/
        #      |    |   |
        #      |    |   |
        #      |    |   |
        #      |   O|___|______> Z right
        #      |   Y up |
        #      |        |
        #      |________|
        #      /        \
        #     /          \
        #    /            \
        #   /              \
        #  4 - CCW          3 - CW
        #
        
        # position wrt local frame of where to apply the thrust force generated by motors 1
        self.force_1_pos = chrono.ChVectorD(l_x, 0.02905, -l_y)
        # position wrt local frame of where to apply the thrust force generated by motors 2 
        self.force_2_pos = chrono.ChVectorD(l_x, 0.02905, l_y) 
        # position wrt local frame of where to apply the thrust force generated by motors 3
        self.force_3_pos = chrono.ChVectorD(-l_x, 0.02905, l_y) 
        # position wrt local frame of where to apply the thrust force generated by motors 4
        self.force_4_pos = chrono.ChVectorD(-l_x, 0.02905, -l_y) 
    
        # Motors' rotation direction
        # Motor 1: CCW
        # Motor 2: CW
        # Motor 3: CCW
        # Motor 4: CW
        # Define spin direction of each motor: +1 for CCW, -1 for CW. SolidWorks Reference Frame (opposite signs wrt mixer matrix)
        self.propellers_spin_directions = [-1, 1, -1, 1]
        
    def _init_x8copter(self):
        # Rotation Matrix that represents a fixed rotation of PI/2 rad around the X-Axis
        RotMat_X_PI_2_list = [[1,  0,  0],
                              [0,  0,  1],
                              [0, -1,  0]]
        RotMat_X_PI_2_array = np.array(RotMat_X_PI_2_list)
        # Rotation Matrix that represents a fixed rotation of -PI/2 rad around the X-Axis
        RotMat_X_PI_2_tran_array = np.transpose(RotMat_X_PI_2_array)
        # Inertia matrix of the system: (drone frame + box + propellers) espressed in Solidworks coordinate sys (x-front, y-up, z-right), computed at the center of mass
        Inertia_mat_sw = np.array([[0.02167468,  1.08e-06, -5.82e-06],
                                   [0.0010034978,  0.01555559, 0.00026918],
                                   [-0.0000065570, -0.0000056584,  0.02225747]])
        
        # Inertia matrix of the system: (drone frame + box + propellers) espressed in Pixhawk coordinate sys (x-front, y-right, z-down), computed at the center of mass
        self.Inertia_mat_pixhawk = np.matmul(RotMat_X_PI_2_array, np.matmul(Inertia_mat_sw, RotMat_X_PI_2_tran_array))

        # self.mass_total_estimated = 2.025 # [kg] 2.025 -- 3.1
        self.mass_total_estimated = 1.99636134
        self.I_matrix_estimated = np.matrix(self.Inertia_mat_pixhawk)
        self.air_density_estimated = self.air_density
        self.surface_area_estimated = self.surface_area
        self.drag_coefficient_estimated = self.drag_coefficient
        self.drag_coefficient_matrix_estimated = np.matrix(np.diag([self.drag_coefficient_estimated,self.drag_coefficient_estimated,0]))

        # Mixer Matrix for the realization of the thrust generated by each motor (T1, T2, T3, T4) given the control inputs (u1, u2, u3, u4)
        # l_x = 0.0881269 # distance between centerline of the drone and the motors along x direction in Local NED convention
        # l_y = 0.1083450 # distance between centerline of the drone and the motors along y direction in Local NED convention
        c_t = 0.01 # drag coefficient of propellers
        
        # Distance of motors from CoM - Taken from CAD model
        l_x_mot1 = 87.565964/1000
        l_x_mot2 = 88.166966/1000
        l_x_mot3 = 87.646064/1000
        l_x_mot4 = 88.086866/1000
        
        l_y_mot1 = 102.169314/1000
        l_y_mot2 = 101.92283/1000
        l_y_mot3 = 115.013694/1000
        l_y_mot4 = 114.76721/1000

        # Mixer matrix for QUADcopter 
        # U_mat = np.array([[ 1,    1,    1,    1  ], 
        #                   [ l_y,  l_y, -l_y, -l_y],
        #                   [-l_x,  l_x,  l_x, -l_x],
        #                   [-c_t,  c_t, -c_t,  c_t]])
        
        # Mixer matrix for X8copter configuration
        # [   1,   1,    1,    1,    1,    1,    1,    1]
        # [ l_y, l_y, -l_y, -l_y,  l_y,  l_y, -l_y, -l_y]
        # [-l_x, l_x,  l_x, -l_x, -l_x,  l_x,  l_x, -l_x]
        # [-c_t, c_t, -c_t,  c_t,  c_t, -c_t,  c_t, -c_t]

        # Moore-Penrose pseudo-inverse of X8copter mixer matrix
        # self.U_mat_inv = np.array([
        #   [1/8,  1/(8*l_y), -1/(8*l_x), -1/(8*c_t)],
        #   [1/8,  1/(8*l_y),  1/(8*l_x),  1/(8*c_t)],
        #   [1/8, -1/(8*l_y),  1/(8*l_x), -1/(8*c_t)],
        #   [1/8, -1/(8*l_y), -1/(8*l_x),  1/(8*c_t)],
        #   [1/8,  1/(8*l_y), -1/(8*l_x),  1/(8*c_t)],
        #   [1/8,  1/(8*l_y),  1/(8*l_x), -1/(8*c_t)],
        #   [1/8, -1/(8*l_y),  1/(8*l_x),  1/(8*c_t)],
        #   [1/8, -1/(8*l_y), -1/(8*l_x), -1/(8*c_t)]
        # ])
        
        self.U_mat = np.array([[1,1,1,1,1,1,1,1],
            [l_y_mot1, l_y_mot2, -l_y_mot3, -l_y_mot4, l_y_mot1, l_y_mot2, -l_y_mot3, -l_y_mot4], 
            [-l_x_mot1, l_x_mot2, l_x_mot3, -l_x_mot4, -l_x_mot1, l_x_mot2, l_x_mot3, -l_x_mot4], 
            [-c_t, c_t, -c_t, c_t, c_t, -c_t, c_t, -c_t]
        ])
        
        self.U_mat_inv = self.U_mat.T @ np.linalg.inv(self.U_mat @ self.U_mat.T)

        # Maximum thrust produced by a single motor = 1355 grams = 1.355 kg = 1.355 kg * 9.81 m/s^2 = 13.28 N
        # Maximum thrust produced by a motors'couple without loss of efficiency due to propeller interaction = 13.28 * 2 = 26.56 N
        # Maximum thrust produced by a motors'couple considering loss of efficiency due to propeller interaction = 26.56 N * 0.8 = 21.25 N
        # For reference see: https://www.getfpv.com/t-motor-pacer-v3-p2306-powerful-freestyle-motor-1750kv-1950kv-2550kv.html
        # self.maximum_motor_thrust = 21.25 # [N] Maximum thrust that can be produced by a motors'couple
        self.maximum_motor_thrust = 21.25/2 # [N] Maximum thrust that can be produced by a SINGLE motor = 10.625 N
        
        # Minimum thrust produced by a single motor = 80 grams = 0.08 kg = 0.08 kg * 9.81 m/s^2 = 0.7848 N
        # Minimum thrust produced by a motors'couple without loss of efficiency due to propeller interaction = 0.7848 * 2 = 1.5696 N
        # Minimum thrust produced by a motors'couple considering loss of efficiency due to propeller interaction = 1.5696 N * 0.8 = 1.255 N
        # self.minimum_motor_thrust = 1.255 # [N] Minimum thrust that can be produced by a motors'couple
        self.minimum_motor_thrust = 1.255/2 # [N] Minimum thrust that can be produced by a SINGLE motor = 0.6275 N
        
        # Motor efficiency coefficients for simulating motor failure
        self.motor_efficiency_matrix = np.matrix(np.diag([1, 1, 1, 1, 1, 1, 1, 1]))
            
        self.K_omega = 0.0000014166615 # Coefficent relating the propellers'thrust to the square of the angular velocity. controller.motor_thrusts = K * omega^2
        self.K_torque = 5e-08 # [5e-08 - 5e-10] TO BE ESTIMATED!!! Coefficent relating the propellers'torque to the square of the angular velocity. Torque = K_torque * omega^2
        
        # position wrt local frame of where to apply the thrust force generated by motors 1 & 5
        self.force_1_5_pos = chrono.ChVectorD(-0.08760601358, -0.0085, -0.10859150436)
        # position wrt local frame of where to apply the thrust force generated by motors 2 & 6 
        self.force_2_6_pos = chrono.ChVectorD(0.08812691616, -0.0085, -0.10834502049) 
        # position wrt local frame of where to apply the thrust force generated by motors 3 & 7
        self.force_3_7_pos = chrono.ChVectorD(0.08760601358, -0.0085, 0.10859150436) 
        # position wrt local frame of where to apply the thrust force generated by motors 4 & 8
        self.force_4_8_pos = chrono.ChVectorD(-0.08812691616, -0.0085, 0.10834502049) 

        # Motors' rotation direction
        # Motor 1: CCW
        # Motor 2: CW
        # Motor 3: CCW
        # Motor 4: CW
        # Motor 5: CW
        # Motor 6: CCW       
        # Motor 7: CW
        # Motor 8: CCW
        # Define spin direction of each motor: +1 for CCW, -1 for CW. SolidWorks Reference Frame (opposite signs wrt mixer matrix)
        self.propellers_spin_directions = [1, -1, 1, -1, -1, 1, -1, 1]