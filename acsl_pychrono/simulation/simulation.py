import os
import time
import sys
import numpy as np
from numpy import linalg as LA

import pychrono as chrono
import pychrono.irrlicht as irr

import acsl_pychrono.simulation.functions as fun
from acsl_pychrono.simulation.visualization import Visualization
from acsl_pychrono.simulation.pixhawk_state import PixhawkState, VehicleState
from acsl_pychrono.simulation.flight_params import FlightParams
from acsl_pychrono.simulation.ode_input import OdeInput
import acsl_pychrono.config.config as Cfg
import acsl_pychrono.user_defined_trajectory as Traj
from acsl_pychrono.simulation.utils import Utils
from acsl_pychrono.control.control import Control

class Simulation:
  def __init__(self, sim_cfg: Cfg.SimulationConfig = Cfg.SimulationConfig()) -> None:
    # Chrono settings
    self.m_sys = chrono.ChSystemNSC()
    self.vis: irr.ChVisualSystemIrrlicht | None = None
    self.visualization = Visualization(self)
    
    # Chrono features
    self.m_ground = None
    self.m_frame: chrono.ChBody = chrono.ChBody()
    self.m_box: chrono.ChBody = chrono.ChBody()
    self.m_props: list[chrono.ChBody] = []
    self.m_markers = []
    self.m_motors = []

    # Vehicle state
    self.vehicle_state: VehicleState = VehicleState()
    self.pixhawk_state: PixhawkState = PixhawkState()

    # Config members
    self.simulation_config: Cfg.SimulationConfig = sim_cfg
    self.mission_config: Cfg.MissionConfig = sim_cfg.mission_config
    self.vehicle_config: Cfg.VehicleConfig = sim_cfg.vehicle_config
    self.environment_config: Cfg.EnvironmentConfig = sim_cfg.environment_config
    self.wrapper_params: Cfg.WrapperParams = sim_cfg.wrapper_params

    # Additional initialization
    self.setUpSimulation()

  def setUpSimulation(self):
    """
    Function to include in __init__() that sets additional simulation settings and performs the setup of the simulation
    """
    self.loadVehicleModel()
    self.loadEnvironmentModel()
    self.setSolverAndCollisionModel()
    self.loadBodies()
    self.loadMarkers()
    self.createAuxillaryCoordinateSystems()
    self.createFloor()
    self.addPayload()
    self.addMotors()
    self.m_frame.Accumulate_force(chrono.ChVectorD(0, 0, 0), chrono.VNULL, True)

  def setGravitationalAcceleration(self, flight_params: FlightParams):
    self.m_sys.Set_G_acc(chrono.ChVectorD(0,-flight_params.G_acc,0))

  def loadVehicleModel(self):
    """
    Assigning names to the bodies imported from solidworks and checking if they are found
    """
    # Prepend working directory and "/assets/vehicles"
    base_path = os.path.join(os.getcwd(), "assets", "vehicles")
    full_path = os.path.join(base_path, self.vehicle_config.model_relative_path)
    # Load the file generated by the SolidWorks CAD plugin and add it to the ChSystem.
    # Remove the trailing .py and add / in case of file without ./
    absfilename = os.path.abspath(full_path)
    modulename = os.path.splitext(absfilename)[0]

    self.exported_items = chrono.ImportSolidWorksSystem(modulename)

    # # Print exported items
    # for my_item in self.exported_items:
    #   print(my_item.GetName())
    # # Add items to the physical system
    for my_item in self.exported_items:
      self.m_sys.Add(my_item)

  def loadBodies(self):
    m_ground = self.m_sys.SearchBody('ground')
    if not m_ground:
      sys.exit('Error: cannot find ground from its name in the C::E system!')    
    self.m_frame = self.m_sys.SearchBody('drone_big_box-1')
    if not self.m_frame:
      sys.exit('Error: cannot find drone frame from its name in the C::E system!')
    self.m_box = self.m_sys.SearchBody('box_big_200x200x100-1')
    if not self.m_box:
      sys.exit('Error: cannot find box from its name in the C::E system!')
    self.m_props = []
    for i in range(1, 9):
      name = f'3_blade_prop-{i}'
      prop = self.m_sys.SearchBody(name)
      if not prop:
        sys.exit(f'Error: cannot find {name} from its name in the C::E system!')
      self.m_props.append(prop)

  def loadMarkers(self):
    """
    Assigning names to the Coordinate Systems/Markers imported from solidworks and checking if they are found
    """
    self.m_markers = []
    for i in range(1, 9):
      name = f'Coordinate System{i}'
      marker = self.m_sys.SearchMarker(name)
      if not marker:
        sys.exit(f'Error: cannot find marker{i} from its name in the C::E system!')
      self.m_markers.append(marker)

  def addMotors(self):
    if not (self.m_frame and self.m_props and self.m_markers):
      sys.exit("Error: frame, props, and markers must be loaded before adding motors!")

    self.m_motors = []
    for i in range(8):
      frame = self.m_markers[i].GetAbsFrame()
      motor = chrono.ChLinkMotorRotationSpeed()
      motor.Initialize(self.m_props[i], self.m_frame, frame)
      motor.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
      # motor.SetMotorFunction(chrono.ChFunction_Const(5.0 * chrono.CH_C_2PI))  # Uncomment if needed
      self.m_sys.Add(motor)
      self.m_motors.append(motor)

  def getBodies(self):
    return (
      self.m_frame,
      self.m_box,
      *self.m_props
    )

  def getMarkers(self):
    return tuple(self.m_markers)
  
  def getMotors(self):
    return tuple(self.m_motors)

  def loadEnvironmentModel(self):
    if not self.environment_config.include:
      print("[INFO] Environment model loading skipped (config.environment.include=False).")
      return
    
    # Prepend working directory and "/assets/environments"
    base_path = os.path.join(os.getcwd(), "assets", "environments")
    full_path = os.path.join(base_path, self.environment_config.model_relative_path)

    # Get absolute module name without .py
    absfilename = os.path.abspath(full_path)
    modulename = os.path.splitext(absfilename)[0]

    # Import the environment model
    self.exported_items_env = chrono.ImportSolidWorksSystem(modulename)

    # Add all items to the physical system
    for item in self.exported_items_env:
      print(item.GetName())
      self.m_sys.Add(item)

    # Filter out 'ground' and only keep bodies
    bodies = [
      item for item in self.exported_items_env
      if isinstance(item, chrono.ChBody) and item.GetName() != "ground"
    ]

    if len(bodies) != 1:
      sys.exit(f"Error: Expected exactly 1 non-ground body in the environment model, found {len(bodies)}.")

    self.m_environment = bodies[0]
    print(f"Environment body loaded: {self.m_environment.GetName()}")

  def setSolverAndCollisionModel(self):
    # self.m_solver = chrono.ChSolverBB() # default solver set by the solidworks pychrono module
    self.m_solver = chrono.ChSolverPSOR() # same solver as 'demo_MBS_collisionNSC'
    self.m_sys.SetSolver(self.m_solver)
    self.m_solver.SetMaxIterations(1000) #600 #1000
    self.m_solver.EnableWarmStart(True)
    chrono.ChCollisionModel.SetDefaultSuggestedEnvelope(0.001) #0.003 #0.001
    chrono.ChCollisionModel.SetDefaultSuggestedMargin(0.0005) #0.003 #0.0005
    chrono.ChCollisionSystemBullet.SetContactBreakingThreshold(0.001) #0.002 #0.001

  def createAuxillaryCoordinateSystems(self):
    # position of the "pixhawk's center" wrt local frame
    self.position_local_pixhawk = chrono.ChVectorD(0.0293, 0.04925, 0) 
    # position of the "pixhawk's center" wrt the COG of the drone frame
    self.position_pixhawk_fromCOG = chrono.ChVectorD(-0.0214807964657055, 0.0779592340719906, -0.0000487571767365452) 
    # Global reference frame
    self.global_coord = chrono.ChCoordsysD(chrono.ChVectorD(0,0,0), chrono.ChQuaternionD(1,0,0,0)) 
    # Coordinate System Pixhawk (NED)
    self.pixhawk_csys = chrono.ChCoordsysD(
      self.position_local_pixhawk,
      chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)
    )
    pixhawk_csys_2 = chrono.ChCoordsysD( # Coordinate System Pixhawk with Y up
      self.position_local_pixhawk,
      chrono.ChQuaternionD(1,0,0,0)
    ) 
    # Create a local reference system with origin in pixhawk and with NED (North East Down) convention
    self.marker_pixhawk =chrono.ChMarker()
    self.marker_pixhawk.SetName('Coordinate System Pixhawk')
    self.m_frame.AddMarker(self.marker_pixhawk)
    self.marker_pixhawk.Impose_Abs_Coord(self.pixhawk_csys)
    
    # Create a local reference system with origin in pixhawk and with Global Frame convention (Y up)
    self.marker_pixhawk_2 =chrono.ChMarker()
    self.marker_pixhawk_2.SetName('Coordinate System Pixhawk Global Frame convention')
    self.m_frame.AddMarker(self.marker_pixhawk_2)
    self.marker_pixhawk_2.Impose_Abs_Coord(pixhawk_csys_2)

    # Rotation matrix that represents a rotation of plus pi/2 (90 degrees) around the x-axis
    self.RR = chrono.ChMatrix33D()
    RRX_plusPI2 = [[1, 0, 0],
                   [0, 0, 1],
                   [0,-1, 0]]
    self.RR.SetMatr(RRX_plusPI2)  # type: ignore

    # Identify Local reference system of Box
    self.m_box_csys = self.m_box.GetFrame_REF_to_abs().GetCoord()
    # Identify Local reference system of drone frame
    self.m_frame_csys = self.m_frame.GetFrame_REF_to_abs().GetCoord()

  def createFloor(self):
    contact_material_floor = chrono.ChMaterialSurfaceNSC()
    contact_material_floor.SetFriction(1) # 1
    contact_material_floor.SetDampingF(0.5) # 0.5
    self.mfloor = chrono.ChBodyEasyBox(50, 0.1, 50, 1000,True,True, contact_material_floor)
    self.mfloor.SetName('Floor')
    self.mfloor.SetBodyFixed(True)
    self.mfloor_Yposition = 0.3
    self.mfloor.SetPos(chrono.ChVectorD(0,-self.mfloor_Yposition,0))
    self.mfloor.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/light_gray.png"))
    self.m_sys.Add(self.mfloor)

  def addTwoSteelBallsPayload(self):
    if (self.mission_config.add_payload_flag and self.mission_config.payload_type == "two_steel_balls"):
      contact_material_ball = chrono.ChMaterialSurfaceNSC()
      ball_radius = 0.0254 # 0.0254 - 0.01905 - 0.015875
      # my_ball_density = 7850
      my_ball_density = getattr(self.wrapper_params, "my_ball_density", 7850)
      self.m_ball1 = chrono.ChBodyEasySphere(
        ball_radius,      # radius size 
        my_ball_density,     # density
        True,     # visualization?
        True,     # collision?
        contact_material_ball # contact material
      )  
      self.m_ball1.SetName('Ball_1')
      self.m_ball1.SetPos(chrono.ChVectorD(-0.05,-0.15,0.065)) # -0.05,-0.15,0
      self.m_ball1.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/redwhite.png"))
      self.m_sys.Add(self.m_ball1)
      
      self.m_ball2 = chrono.ChBodyEasySphere(
        ball_radius,      # radius size
        my_ball_density,     # density
        True,     # visualization?
        True,     # collision?
        contact_material_ball # contact material
      )  
      self.m_ball2.SetName('Ball_2')
      self.m_ball2.SetPos(chrono.ChVectorD(0.05,-0.15,0.065))
      self.m_ball2.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/checker2.png"))
      self.m_sys.Add(self.m_ball2)

      # Identify Local reference system of Ball_1
      self.my_ball1_csys = self.m_ball1.GetFrame_REF_to_abs().GetCoord()
      # Identify Local reference system of Ball_2
      self.my_ball2_csys = self.m_ball2.GetFrame_REF_to_abs().GetCoord()

      self.setupCOMcomputationOfSystemWithPayload()

  def setupCOMcomputationOfSystemWithPayload(self):
    if (self.mission_config.add_payload_flag and self.mission_config.payload_type == "two_steel_balls"):
      # Computing Center Of Mass (COM) of the system: drone frame + box + propellers + balls
      # Get the mass of each body
      self.m_frame_mass = self.m_frame.GetMass()
      self.m_box_mass = self.m_box.GetMass()
      self.m_prop_mass = self.m_props[0].GetMass() # same for each propeller
      self.m_ball1_mass = self.m_ball1.GetMass()
      self.m_ball2_mass = self.m_ball2.GetMass()
      
      self.mass_total = self.m_frame_mass + self.m_box_mass + 8*(self.m_prop_mass)
      self.mass_total_wballs = self.mass_total + self.m_ball1_mass + self.m_ball2_mass
      
      self.COG_total = chrono.ChVectorD()
      self.COG = chrono.ChVectorD()

  def updateCOMcomputationOfSystemWithPayload(self):
    if (self.mission_config.add_payload_flag and self.mission_config.payload_type == "two_steel_balls"):
      # Computing Center Of Mass (COM) of the system: drone frame + box + propellers + balls
          
      # Compute the position (in global coordinates) of the bodies
      # Global coordinates of the origin of the drone frame containing just the position
      my_frame_pos_GLOB = self.m_frame.GetPos() 
      # This gives the position of the auxillary csys imported from/defined in SolidWorks
      # my_box_ref = my_box.GetFrame_REF_to_abs().GetCoord().pos 
      # Same as asking for .GetPos() --> meaning GetPos() refers to the COG position!!!!
      my_box_pos = self.m_box.GetFrame_COG_to_abs().GetCoord().pos 
      my_prop1_pos = self.m_props[0].GetPos()
      my_prop2_pos = self.m_props[1].GetPos()
      my_prop3_pos = self.m_props[2].GetPos()
      my_prop4_pos = self.m_props[3].GetPos()
      my_prop5_pos = self.m_props[4].GetPos()
      my_prop6_pos = self.m_props[5].GetPos()
      my_prop7_pos = self.m_props[6].GetPos()
      my_prop8_pos = self.m_props[7].GetPos()
      
      # Compute the COG in Global Coordinates
      # (First you must put the ChVector (position) and then you can multiply it by a float (mass). Order is important!!!)
      self.COG_total = (
        my_frame_pos_GLOB * self.m_frame_mass
        + my_box_pos * self.m_box_mass
        + (my_prop1_pos + my_prop2_pos + my_prop3_pos + my_prop4_pos +
          my_prop5_pos + my_prop6_pos + my_prop7_pos + my_prop8_pos
          ) * 8 * self.m_prop_mass
        + self.m_ball1.GetPos() * self.m_ball1_mass 
        + self.m_ball2.GetPos() * self.m_ball2_mass
      ) * (1 / self.mass_total_wballs)
      
      self.COG = (
        my_frame_pos_GLOB * self.m_frame_mass
        + my_box_pos * self.m_box_mass
        + (my_prop1_pos + my_prop2_pos + my_prop3_pos + my_prop4_pos +
          my_prop5_pos + my_prop6_pos + my_prop7_pos + my_prop8_pos
          ) * 8 * self.m_prop_mass
      ) * (1 / self.mass_total)
      
      self.my_COG_local = self.m_frame_csys.TransformParentToLocal(self.COG) # Position of COG seen from the local reference system of the frame
      
      # Ball position seen from Box refrence system
      # Position of Ball1 seen from the local reference system of the Box
      self.my_ball1_pos_box = self.m_box_csys.TransformParentToLocal(self.m_ball1.GetPos()) 
      # Position of Ball2 seen from the local reference system of the Box
      self.my_ball2_pos_box = self.m_box_csys.TransformParentToLocal(self.m_ball2.GetPos()) 
      # Position of COG_total seen from the local reference system of the Box
      self.COG_total_box = self.m_box_csys.TransformParentToLocal(self.COG_total) 

  def addSpheresInArrays(self):
    if (self.mission_config.add_payload_flag
      and self.mission_config.payload_type == "ten_steel_balls_in_two_lines"
      ):
      self.m_spheres: list[chrono.ChBody] = []  # Store sphere bodies
      contact_material_ball = chrono.ChMaterialSurfaceNSC()
      radius = 0.015875
      density = 7850
      sphere_number = 10
      for i in range(sphere_number):
        sphere_body = chrono.ChBodyEasySphere(radius, density, True, True, contact_material_ball)
        sphere_body.SetName(f"Ball_3_{i}")
        
        # Arrange spheres in 2 rows of 5
        x = -0.05 + 0.035 * i * (i < 5) + 0.035 * (i - 5) * (i >= 5)
        y = -0.2
        z = -0.05 + 0.1 * (i >= 5)
        sphere_body.SetPos(chrono.ChVectorD(x, y, z))

        # Texture (optional)
        sphere_body.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/redwhite.png"))

        self.m_sys.Add(sphere_body)
        self.m_spheres.append(sphere_body)

  def addRandomSpheres(self):
    if (self.mission_config.add_payload_flag
      and self.mission_config.payload_type == "many_steel_balls_in_random_position"
      ):
      self.m_spheres: list[chrono.ChBody] = []  # Store sphere bodies
      contact_material_ball = chrono.ChMaterialSurfaceNSC()
      radius = 0.015875
      density = 7850
      sphere_number = 10
      for i in range(sphere_number):
        sphere = chrono.ChBodyEasySphere(
          radius,
          density,
          True,   # visualization
          True,   # collision
          contact_material_ball
        )
        sphere.SetName(f"Ball_3_{i}")
        sphere.SetPos(chrono.ChVectorD(
          -0.05 + chrono.ChRandom() * 0.1,
          -0.2  + chrono.ChRandom() * 0.05,
          -0.05 + chrono.ChRandom() * 0.1
        ))
        sphere.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/checker1.png"))

        self.m_sys.Add(sphere)
        self.m_spheres.append(sphere)

  def addPayload(self):
    self.addTwoSteelBallsPayload()
    self.addSpheresInArrays()
    self.addRandomSpheres()

  def updatePixhawkState(self):
    coord_GLOB = self.marker_pixhawk.GetAbsCoord()
    coord_dt_GLOB = self.marker_pixhawk.GetAbsCoord_dt()
    coord_dtdt_GLOB = self.marker_pixhawk.GetAbsCoord_dtdt()
    Wvel_GLOB = self.marker_pixhawk.GetAbsWvel()
    Wacc_GLOB = self.marker_pixhawk.GetAbsWacc()

    rotmat = chrono.ChMatrix33D(coord_GLOB.rot)
    rotmat_F = fun.rotmat_fromQ_Glob_to_Loc_asChMatrix33(coord_GLOB.rot)

    pos_LOC = rotmat_F * coord_GLOB.pos
    vel_LOC = rotmat_F * coord_dt_GLOB.pos
    acc_LOC = rotmat_F * coord_dtdt_GLOB.pos
    Wvel_LOC = rotmat_F * Wvel_GLOB
    Wacc_LOC = rotmat_F * Wacc_GLOB

    pos_LOC_to_GLOB = rotmat * pos_LOC
    pos_LOC_to_GLOB_NED = self.RR * pos_LOC_to_GLOB
    vel_LOC_to_GLOB = rotmat * vel_LOC
    vel_LOC_to_GLOB_NED = self.RR * vel_LOC_to_GLOB
    Wvel_LOC_to_GLOB = rotmat * Wvel_LOC
    Wvel_LOC_to_GLOB_NED = self.RR * Wvel_LOC_to_GLOB

    quat = self.marker_pixhawk_2.GetAbsCoord().rot
    quat_fixed = chrono.ChQuaternionD(quat.e0, -quat.e1, -quat.e3, quat.e2)
    rotmat_euler321 = fun.rotmat_fromQ_Glob_to_Loc_asChMatrix33(quat_fixed)
    euler321 = fun.euler321_from_rotmat(rotmat_euler321)

    self.pixhawk_state = PixhawkState(
      coord_GLOB=coord_GLOB,
      coord_dt_GLOB=coord_dt_GLOB,
      coord_dtdt_GLOB=coord_dtdt_GLOB,
      Wvel_GLOB=Wvel_GLOB,
      Wacc_GLOB=Wacc_GLOB,
      rotmat=rotmat,
      rotmat_F=rotmat_F,
      pos_LOC=pos_LOC,
      vel_LOC=vel_LOC,
      acc_LOC=acc_LOC,
      Wvel_LOC=Wvel_LOC,
      Wacc_LOC=Wacc_LOC,
      pos_LOC_to_GLOB=pos_LOC_to_GLOB,
      pos_LOC_to_GLOB_NED=pos_LOC_to_GLOB_NED,
      vel_LOC_to_GLOB=vel_LOC_to_GLOB_NED,
      vel_LOC_to_GLOB_NED=vel_LOC_to_GLOB_NED,
      Wvel_LOC_to_GLOB=Wvel_LOC_to_GLOB,
      Wvel_LOC_to_GLOB_NED=Wvel_LOC_to_GLOB_NED,
      quat_fixed=quat_fixed,
      euler321=euler321
    )  

  def getVehicleState(self) -> VehicleState:
    """
    Return the current vehicle state with attitude, position, and velocity data.
    """
    roll = self.pixhawk_state.euler321.x
    pitch = self.pixhawk_state.euler321.y
    yaw = self.pixhawk_state.euler321.z
    translational_position_in_I = np.array(fun.chvector_to_list(self.pixhawk_state.pos_LOC_to_GLOB_NED)).reshape(3,1)
    translational_velocity_in_I = np.array(fun.chvector_to_list(self.pixhawk_state.vel_LOC_to_GLOB_NED)).reshape(3,1)
    angular_velocity = np.array(fun.chvector_to_list(self.pixhawk_state.Wvel_LOC)).reshape(3,1)
    # angular_acceleration = np.array(fun.chvector_to_list(self.pixhawk_state.Wacc_LOC)).reshape(3,1)

    return VehicleState(
      roll=roll,
      pitch=pitch,
      yaw=yaw,
      position_global=translational_position_in_I,
      velocity_global=translational_velocity_in_I,
      angular_velocity_local=angular_velocity
    )
  
  def applyAerodynamicForce(self, flight_params: FlightParams):
    aerodynamic_velocity = np.array(fun.chvector_to_list(self.pixhawk_state.vel_LOC)).reshape(3,1)
    aerodynamic_force = (
      -0.5 * flight_params.air_density_estimated * 
      flight_params.surface_area_estimated * 
      flight_params.drag_coefficient_matrix_estimated * 
      aerodynamic_velocity * LA.norm(aerodynamic_velocity)
    )

    application_point = chrono.ChVectorD(-0.006329836449057219, -0.05730872796244302, 3.945863912075595e-05)

    self.m_frame.Accumulate_force(
      chrono.ChVectorD(aerodynamic_force[0].item(), aerodynamic_force[1].item(), aerodynamic_force[2].item()),
      application_point,
      True
    )

  def applyWindForce(self, wind_force_vector: tuple[float, float, float], apply: bool = False):
    """
    Apply a constant wind force to the UAV if `apply` is True.

    Args:
        wind_force_vector: A tuple of (x, y, z) wind force components in the global frame.
        apply: Whether or not to apply the wind force.
    """
    if not apply:
      return
    
    applicaion_point = chrono.ChVectorD(-0.006329836449057219, -0.05730872796244302, 3.945863912075595e-05)
    self.m_frame.Accumulate_force(
      chrono.ChVectorD(*wind_force_vector), 
      applicaion_point,
      False
    )

  def applyMotorThrustLimitsAndEfficiency(self, controller, flight_params: FlightParams):
    """Clamp motor thrusts to physical limits and apply motor efficiency."""
    # Thrust saturation
    for i in range(len(controller.motor_thrusts)):
      if controller.motor_thrusts[i][0] < flight_params.minimum_motor_thrust:
        # if some component of the thrust force is smaller than the min thrust that can physically
        # be generated set it to flight_params.minimum_motor_thrust
        controller.motor_thrusts[i][0] = flight_params.minimum_motor_thrust 
      if controller.motor_thrusts[i][0] > flight_params.maximum_motor_thrust:
        # if some component of the thrust force is greater than the max thrust that can physically
        # be generated set it to flight_params.maximum_motor_thrust
        controller.motor_thrusts[i][0] = flight_params.maximum_motor_thrust 

    # Accounting for motor efficiency
    controller.motor_thrusts = np.array(flight_params.motor_efficiency_matrix * controller.motor_thrusts)
  
  def applyMotorForces(self, controller, flight_params: FlightParams):
    """Apply thrust forces from motors at predefined local positions wrt the drone frame."""    
    # Define thrust application points
    force_positions = (
      flight_params.force_1_5_pos,
      flight_params.force_2_6_pos,
      flight_params.force_3_7_pos,
      flight_params.force_4_8_pos
    )

    # Map motor indices to force positions
    motor_to_pos_index = [2, 3, 0, 1, 6, 7, 4, 5] # alternative [0, 1, 2, 3, 4, 5, 6, 7]

    for i, motor_idx in enumerate(motor_to_pos_index):
      force_vec = chrono.ChVectorD(0, controller.motor_thrusts[motor_idx][0], 0)
      force_pos = force_positions[i % 4] # means (0, 1, 2, 3, 0, 1, 2, 3)
      self.m_frame.Accumulate_force(force_vec, force_pos, True)

  def applyPropellerReactionTorques(self, controller, flight_params: FlightParams):
    """
    Computes and applies the individual reaction torques generated by each of the 8 propellers
    based on their angular velocities and spin direction.
    """
    # Compute angular velocities for each motor
    self.omega = np.sqrt(controller.motor_thrusts / flight_params.K_omega)

     # Compute and apply torques
    for i in range(8):
      omega_squared = self.omega[i][0] ** 2
      torque_y = flight_params.propellers_spin_directions[i] * omega_squared * flight_params.K_torque
      torque = chrono.ChVectorD(0, torque_y, 0)
      self.m_frame.Accumulate_torque(torque, True)

  def setPropellerRotationalVelocity(self, flight_params: FlightParams):
    """
    Sets the rotational velocity for each propeller motor link,
    based on the signed angular velocities.
    """
    # Compute the signed angular velocities
    omega_signed = [
        flight_params.propellers_spin_directions[i] * self.omega[i][0]
        for i in range(8)
    ]

    reducing_factor = 10
    for i in range(8):
      omega_reduced = omega_signed[i] / reducing_factor
      self.m_motors[i].SetMotorFunction(chrono.ChFunction_Const(omega_reduced))

  def handlePayloadDroppingBalls12(self, time_now: float, apply: bool = False):
    """
    Temporarily disables and then re-enables collisions for the payloads to simulate dropping them if `apply` is True.

    Parameters:
    - time_now (float): The current simulation time.
    - apply (bool): Whether or not to apply the payload dropping.
    """
    if not apply:
      return
    
    if (self.mission_config.add_payload_flag and self.mission_config.payload_type == "two_steel_balls"):
      drop_time = 3.7 # Time at which payloads should be dropped.
      disable_duration = 0.15 # Time duration for which collisions are disabled after the drop.

      if (time_now > drop_time):
        self.m_ball1.SetCollide(False)
        self.m_ball2.SetCollide(False) 
      if (time_now > (drop_time + disable_duration)):
        self.m_ball1.SetCollide(True)
        self.m_ball2.SetCollide(True)

  def handleMotorFailure(self, time_now: float, flight_params: FlightParams, apply: bool = False):
    """
    Modifies the motor efficiency matrix that simulates motor failure after a given time.

    Parameters:
    - time_now (float): The current simulation time.
    - apply (bool): Whether or not to apply the motor failure.
    """
    if not apply:
      return

    failure_time = 6.5 # 4.5
    motor_efficiencies = [0, 1, 1, 1, 1, 1, 1, 1]
    if (time_now > failure_time):
      flight_params.motor_efficiency_matrix = np.matrix(np.diag(motor_efficiencies))

  def sequentiallyDropBalls(self, time_now: float, apply: bool = False):
    """
    Toggles collision state of balls one by one to simulate sequential payload dropping.

    Parameters:
    - time_now (float): Current simulation time.
    - apply (bool): Whether or not to apply the payload dropping.
    """
    if not apply:
      return

    if (self.mission_config.add_payload_flag and self.mission_config.payload_type != "two_steel_balls"):
      drop_start_time = 3.0 # Time at which the first ball starts dropping
      drop_interval = 0.10 # Time delay between successive ball drops.
      disable_duration = 0.15 # How long each ball should stay non-collidable

      if not hasattr(self, "m_spheres") or len(self.m_spheres) == 0:
        return  # No spheres to drop
      
      for i, ball in enumerate(self.m_spheres):
        drop_time_i = drop_start_time + i * drop_interval
        reenable_time_i = drop_time_i + disable_duration

        if time_now < drop_time_i:
          # Ball hasn't dropped yet — keep collision on
          ball.SetCollide(True)
        elif drop_time_i <= time_now < reenable_time_i:
          # Ball is in its disabled phase — collision off
          ball.SetCollide(False)
        else:
          # Disable duration passed — re-enable collision
          ball.SetCollide(True)

  def assignInstances(
    self,
    flight_params: FlightParams,
    ode_input: OdeInput,
    user_defined_trajectory: Traj.BaseUserDefinedTrajectory,
    gains,
    controller: Control,
    logger
    ):

    self.flight_params = flight_params
    self.ode_input = ode_input
    self.user_defined_trajectory = user_defined_trajectory
    self.gains = gains
    self.controller = controller
    self.logger = logger

  def runSimulationLoop(self):
    self.visualization.setup()
    start_sim_time = time.time() # Time acquired in order to measure the execution time of the simulation

    # Simulation loop
    while self.m_sys.GetChTime() < self.mission_config.simulation_duration_seconds:
      if not self.visualization.update():
        break # Exit loop if visualization window is closed

      self.stepSimulation(start_sim_time)

  def stepSimulation(self, start_sim_time: float):
    self.m_sys.DoStepDynamics(self.mission_config.timestep)
    # Empty_forces_accumulators() MUST be used in conjunction with 
    # Accumulate_force() and Accumulate_torque() used to apply forces and torques
    self.m_frame.Empty_forces_accumulators()

    time_now = self.m_sys.GetChTime() # Time "inside" the simulation
    simulation_time = time.time() - start_sim_time # Time that the simulation is taking

    self.updateSystemStates(time_now)
    self.applyExternalForces()
    self.handlePayloadMechanisms(time_now)
    self.handleFaults(time_now)
    self.runControllerIfStarted(time_now, simulation_time)

    self.debugPrints(time_now, simulation_time)

  def updateSystemStates(self, time_now: float):
    # Computing Center Of Mass (COM) of the system: drone frame + box + propellers + balls
    self.updateCOMcomputationOfSystemWithPayload()
    self.updatePixhawkState()
    # Compute user-defined trajectory
    user_defined_trajectory_state = self.user_defined_trajectory.compute(time_now)
    # Collect vehicle state
    vehicle_state = self.getVehicleState()
    # Collect together inputs to be sent to the controller
    self.ode_input.update(
      time_now,
      vehicle_state,
      user_defined_trajectory_state
    )
  
  def applyExternalForces(self):
    # Applying AERODYNAMIC FORCE to the drone
    self.applyAerodynamicForce(self.flight_params)
    # Applying a constant WIND FORCE to the drone, expressed in pychrono global coordinate
    self.applyWindForce((1.0, 0.0, 0.0), apply=False)

  def runControllerIfStarted(self, time_now: float, simulation_time: float):
    if time_now <= self.flight_params.controller_start_time:
      return

    # Execute the control algorithm
    self.controller.run(self.ode_input)

    # Thrust saturation
    self.applyMotorThrustLimitsAndEfficiency(self.controller, self.flight_params)
    # Applying motor thrust forces
    self.applyMotorForces(self.controller, self.flight_params)
    # Apply propellers reaction torques around local yaw-axis
    self.applyPropellerReactionTorques(self.controller, self.flight_params)
    # Setting the propeller rotational velocities
    self.setPropellerRotationalVelocity(self.flight_params)

    # Collect the log data
    self.logger.collectData(self.controller, simulation_time)

  def handlePayloadMechanisms(self, time_now: float):
    # Payload Dropping
    self.handlePayloadDroppingBalls12(time_now, apply=False)
    # Dropping multiple balls one after the other
    self.sequentiallyDropBalls(time_now, apply=False)

  def handleFaults(self, time_now: float):
    # Motor failure
    self.handleMotorFailure(time_now, self.flight_params, apply=False)

  def debugPrints(self, time_now: float, simulation_time: float):
    # Print data to Console
    Utils.printSimulationTimeInline(
      'Simulation time', time_now,
      'Time the simulation is taking', simulation_time
    )
    # print("m_ball1.GetMass(): ", self.m_ball1.GetMass())
    Utils.printControllerDebugInfo(
      self.controller, time_now, self.flight_params,
      print_console_flag=False
    )












  




